package io.github.debug.xml2jdto.core.jaxb;

import java.io.InputStream;
import java.io.StringReader;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.security.InvalidParameterException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.xml.XMLConstants;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.MarshalException;
import jakarta.xml.bind.Marshaller;
import jakarta.xml.bind.PropertyException;
import jakarta.xml.bind.UnmarshalException;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.ValidationEvent;

import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.ls.LSResourceResolver;

import io.github.debug.xml2jdto.core.exception.ExBuilder;
import io.github.debug.xml2jdto.core.exception.InvalidMethodParameterException;
import io.github.debug.xml2jdto.core.exception.InvalidXmlSchemaException;
import io.github.debug.xml2jdto.core.exception.MalformedXmlException;
import io.github.debug.xml2jdto.core.exception.Xml2jDtoException;
import io.github.debug.xml2jdto.core.jaxb.catalog.CatalogResourceResolver;
import io.github.debug.xml2jdto.core.jaxb.event.XsdValidationEventCollector;

/**
 * Utility class for working with JAXB (Java Architecture for XML Binding).
 * <p>
 * This class provides methods to retrieve {@link JAXBContext} instances and to unmarshal XML strings into Java objects. It uses a cache to store
 * {@link JAXBContext} instances for different classes to improve performance.
 * </p>
 * <p>
 * Example usage:
 * 
 * <pre>
 * {@code
 * MyObject obj = JaxbUtil.unmarshal(xmlString, MyObject.class);
 * }
 * </pre>
 * 
 * <br/>
 * Thread-safety: This class is thread-safe.
 * 
 * @author scheffer.imrich
 */
public final class JaxbUtil {

    private static final Map<String, JAXBContext> jaxbContextCache = new ConcurrentHashMap<>();
    private static final Map<String, Schema> schemaCache = new ConcurrentHashMap<>();

    private static final Logger log = Logger.getLogger(JaxbUtil.class.getName());

    /**
     * A constant error message indicating that the class parameter cannot be null.
     */
    public static final String CLAZZ_NULL_MSG = "clazz cannot be null!";

    /**
     * A map containing default properties for a JAXB marshaller.
     * <p>
     * The properties included are:
     * <ul>
     * <li>{@code Marshaller.JAXB_ENCODING} - Set to UTF-8 encoding.</li>
     * <li>{@code Marshaller.JAXB_FORMATTED_OUTPUT} - Set to false for formatted output.</li>
     * <li>{@code Marshaller.JAXB_FRAGMENT} - Set to false to include the XML declaration.</li>
     * </ul>
     */
    public static final Map<String, Object> DEFAULT_MARSHALLER_PROPERTIES = Map
            .of(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.name(), Marshaller.JAXB_FORMATTED_OUTPUT, false, Marshaller.JAXB_FRAGMENT, false);

    private JaxbUtil() {
        super();
    }

    /**
     * Retrieves the {@link JAXBContext} for the given class. If the context is already cached, it returns the cached instance. Otherwise, it creates
     * a new {@link JAXBContext}, caches it, and then returns it.
     * <p>
     * The JAXBContext must be created only once for each class, as creating it multiple times can cause performance issues.
     * 
     * @param clazz
     *            the class for which the {@link JAXBContext} is to be retrieved
     * @return the {@link JAXBContext} for the given class
     * 
     * @throws InvalidMethodParameterException
     *             if the provided class is null
     */
    public static JAXBContext getJAXBContext(Class<?> clazz) {
        if (clazz == null) {
            throw new InvalidMethodParameterException(CLAZZ_NULL_MSG);
        }
        String className = clazz.getName();
        return jaxbContextCache.computeIfAbsent(className, key -> {
            try {
                return JAXBContext.newInstance(clazz);
            } catch (JAXBException e) {
                throw ExBuilder.newXml2jDtoException()
                        .withMessage("Error creating JAXBContext for class [{0}]: [{1}]", clazz.getName(), e.getLocalizedMessage())
                        .withCause(e)
                        .build();
            }
        });
    }

    /**
     * Retrieves a cached {@link JAXBContext} instance for the specified classes, or creates and caches a new one if not present.
     * <p>
     * This method ensures that JAXBContext instances are reused for the same set of classes, improving performance by avoiding repeated context
     * creation. The cache key is generated by joining the fully qualified class names of the provided classes.
     * </p>
     *
     * @param forClasses
     *            the classes to be bound by the JAXBContext; must not be {@code null}
     * @return a {@link JAXBContext} instance for the specified classes
     * @throws InvalidParameterException
     *             if {@code forClasses} is {@code null}
     * @throws Xml2jDtoException
     *             if an error occurs while creating the {@link JAXBContext}
     */
    public static JAXBContext getJAXBContext(Class<?>... forClasses) {
        if (forClasses == null) {
            throw new InvalidParameterException("forClasses is null!");
        }
        String joinedClassName = Arrays.stream(forClasses).map(c -> c == null ? "null" : c.getName()).sorted().collect(Collectors.joining("|"));
        if (jaxbContextCache.containsKey(joinedClassName)) {
            return jaxbContextCache.get(joinedClassName);
        } else {
            try {
                JAXBContext jaxbContext = JAXBContext.newInstance(forClasses);
                jaxbContextCache.put(joinedClassName, jaxbContext);
                return jaxbContext;
            } catch (JAXBException | IllegalArgumentException e) {
                throw ExBuilder.newXml2jDtoException()
                        .withMessage("Error creating JAXBContext for class [{0}]: [{1}]", joinedClassName, e.getLocalizedMessage())
                        .withCause(e)
                        .build();
            }
        }
    }

    /**
     * Unmarshals the given XML string into an object of the specified class type.
     *
     * @param <T>
     *            the type of the object to be returned
     * @param xml
     *            the XML string to be unmarshalled
     * @param clazz
     *            the class of the object to be returned
     * @return the unmarshalled object of type T, or null if the XML string is blank
     * @throws InvalidMethodParameterException
     *             if the clazz parameter is null
     * @throws Xml2jDtoException
     *             if an error occurs during unmarshalling
     */
    @SuppressWarnings("unchecked")
    public static <T> T unmarshal(String xml, Class<T> clazz) {
        if (StringUtils.isBlank(xml)) {
            return null;
        }
        if (clazz == null) {
            throw new InvalidMethodParameterException(CLAZZ_NULL_MSG);
        }
        try {
            JAXBContext jaxbContext = getJAXBContext(clazz);
            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            return (T) unmarshaller.unmarshal(new StringReader(xml));
        } catch (JAXBException e) {
            // we should not log the whole message, because it can be very long
            throw ExBuilder.newXml2jDtoException()
                    .withMessage(
                            "Unmarshalling error for class [{0}], XML [{1}]: [{2}]",
                            clazz.getName(),
                            StringUtils.abbreviate(xml, 500),
                            e.getLocalizedMessage())
                    .withCause(e)
                    .build();
        }
    }

    /**
     * Retrieves a {@link Schema} object based on the provided XSD path and resource resolver.
     *
     * @param xsdPath
     *            the path to the XSD file. Must not be blank.
     * @param lsResourceResolver
     *            the resource resolver to use. Must not be null.
     * @return the {@link Schema} object created from the XSD file.
     * @throws InvalidMethodParameterException
     *             if the xsdPath is blank or the lsResourceResolver is null.
     * @throws Xml2jDtoException
     *             if the schema cannot be found or an unexpected error occurs during schema creation.
     */
    public static Schema loadSchemaFromXsdPath(String xsdPath, LSResourceResolver lsResourceResolver) {
        if (StringUtils.isBlank(xsdPath) || Objects.isNull(lsResourceResolver)) {
            throw new InvalidMethodParameterException(
                    MessageFormat.format("xsdPath cannot be null: [{0}] or lsResourceResolver cannot be null: [{1}]!", xsdPath, lsResourceResolver));
        }

        try {
            InputStream stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(xsdPath);
            if (stream == null) {
                throw ExBuilder.newXml2jDtoException().withMessage("Schema on path [{0}] cannot be found!", xsdPath).build();
            }

            StreamSource src = new StreamSource(stream);
            SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            sf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            sf.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
            sf.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
            sf.setResourceResolver(lsResourceResolver);
            Schema schema = sf.newSchema(src);
            log.fine(MessageFormat.format("Schema creation finished for XSD: [{0}]", xsdPath));
            return schema;
        } catch (Xml2jDtoException e) {
            throw e;
        } catch (Exception e) {
            throw ExBuilder.newXml2jDtoException()
                    .withMessage("Unexpected error during schema creation for XSD: [{0}]", xsdPath)
                    .withCause(e)
                    .build();
        }
    }

    /**
     * Retrieves the XML Schema object for the given XSD path. If the schema is already cached, it returns the cached schema. Otherwise, it loads the
     * schema from the specified XSD path, caches it, and then returns the loaded schema.
     *
     * @param xsdPath
     *            the path to the XSD file. Must not be null or blank.
     * @return the XML Schema object corresponding to the given XSD path.
     * @throws InvalidMethodParameterException
     *             if the xsdPath is null or blank.
     */
    public static Schema getSchema(String xsdPath) {
        if (StringUtils.isBlank(xsdPath)) {
            throw new InvalidMethodParameterException("xsdPath cannot be null!");
        }
        return schemaCache.computeIfAbsent(xsdPath, key -> loadSchemaFromXsdPath(xsdPath, new CatalogResourceResolver()));
    }

    /**
     * Unmarshals the given XML string into an object of the specified class type. If the provided XSD path is not null, the unmarshalling process is
     * schema-validated.
     * 
     * @param <T>
     *            the type of the object to be returned
     * @param xml
     *            the XML string to be unmarshalled
     * @param clazz
     *            the class of the object to be returned
     * @param xsdPath
     *            the path to the XSD file. If null, no schema validation is performed.
     * @return the unmarshalled object of type T, or null if the XML string is blank
     * @throws InvalidMethodParameterException
     *             if the clazz parameter is null
     * @throws Xml2jDtoException
     *             if an error occurs during unmarshalling
     */
    @SuppressWarnings("unchecked")
    public static <T> T unmarshal(String xml, Class<T> clazz, String xsdPath) {
        if (Objects.isNull(xml)) {
            return null;
        }
        if (clazz == null) {
            throw new InvalidMethodParameterException(CLAZZ_NULL_MSG);
        }
        XsdValidationEventCollector eventCollector = new XsdValidationEventCollector();
        List<ValidationEvent> events = new ArrayList<>();
        try {
            JAXBContext jaxbContext = getJAXBContext(clazz);
            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            unmarshaller.setEventHandler(eventCollector);
            if (xsdPath != null) {
                Schema schema = getSchema(xsdPath);
                if (schema != null) {
                    unmarshaller.setSchema(schema);
                }
            }
            T result = (T) unmarshaller.unmarshal(new StringReader(xml));

            events = eventCollector.getEvents();
            if (!events.isEmpty()) {
                throw new InvalidXmlSchemaException(events);
            }

            return result;
        } catch (UnmarshalException e) {
            throw new MalformedXmlException(events, e);
        } catch (JAXBException e) {
            // we should not log the whole message, because it can be very long
            throw ExBuilder.newXml2jDtoException()
                    .withMessage(
                            "Unmarshalling error for class [{0}], XML [{1}]: [{2}]",
                            clazz.getName(),
                            StringUtils.abbreviate(xml, 500),
                            e.getLocalizedMessage())
                    .withCause(e)
                    .build();
        }
    }

    /**
     * Unmarshals the given XML input stream into an object of the specified class, optionally validating against an XSD schema.
     *
     * <p>
     * This method uses JAXB to convert the XML data from the provided {@link InputStream} into an instance of the given class type. If an XSD schema
     * path is provided, the XML is validated against the schema during unmarshalling. Validation events are collected, and if any validation errors
     * are found, an {@link InvalidXmlSchemaException} is thrown. If the XML is malformed, a {@link MalformedXmlException} is thrown.
     * </p>
     *
     * @param <T>
     *            the type of the object to unmarshal to
     * @param xmlInputStream
     *            the input stream containing the XML data; may be {@code null}
     * @param clazz
     *            the class of the object to unmarshal to; must not be {@code null}
     * @param xsdPath
     *            the path to the XSD schema for validation; may be {@code null} if no validation is required
     * @return an instance of {@code T} populated from the XML, or {@code null} if {@code xmlInputStream} is {@code null}
     * @throws InvalidParameterException
     *             if {@code clazz} is {@code null}
     * @throws InvalidXmlSchemaException
     *             if XML validation against the schema fails
     * @throws MalformedXmlException
     *             if the XML is malformed and cannot be unmarshalled
     * @throws Xml2jDtoException
     *             for other JAXB-related errors during unmarshalling
     */
    public static <T> T unmarshal(InputStream xmlInputStream, Class<T> clazz, String xsdPath) {
        if (Objects.isNull(xmlInputStream)) {
            return null;
        }
        if (clazz == null) {
            throw new InvalidParameterException(CLAZZ_NULL_MSG);
        }
        XsdValidationEventCollector eventCollector = new XsdValidationEventCollector();
        List<ValidationEvent> events = new ArrayList<>();
        try {
            JAXBContext jaxbContext = getJAXBContext(clazz);
            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            unmarshaller.setEventHandler(eventCollector);
            if (xsdPath != null) {
                Schema schema = getSchema(xsdPath);
                if (schema != null) {
                    unmarshaller.setSchema(schema);
                }
            }
            T result = clazz.cast(unmarshaller.unmarshal(xmlInputStream));

            events = eventCollector.getEvents();
            if (!events.isEmpty()) {
                throw new InvalidXmlSchemaException(events);
            }

            return result;
        } catch (UnmarshalException e) {
            throw new MalformedXmlException(events, e);
        } catch (JAXBException e) {
            // we should not log the whole message, because it can be very long
            throw ExBuilder.newXml2jDtoException()
                    .withMessage(
                            "Unmarshalling error for class [{0}], InputStream [{1}]: [{2}]",
                            clazz.getName(),
                            xmlInputStream,
                            e.getLocalizedMessage())
                    .withCause(e)
                    .build();
        }
    }

    /**
     * Marshals the given DTO (Data Transfer Object) into an XML string. Uses the default marshaller properties: UTF-8 encoding and formatted output.
     *
     * @param <T>
     *            the type of the DTO
     * @param dto
     *            the DTO object to be marshaled; if null, the method returns null
     * @return the XML string representation of the DTO object, or null if the DTO is null
     */
    public static <T> String marshal(T dto) {
        return marshal(dto, null, DEFAULT_MARSHALLER_PROPERTIES, (Class<?>[]) null);
    }

    /**
     * Marshals the given DTO object into a formatted XML string.
     * <p>
     * This method sets the {@link Marshaller#JAXB_FORMATTED_OUTPUT} property to {@code true}, ensuring that the resulting XML output is
     * human-readable and properly indented.
     * </p>
     *
     * @param <T>
     *            the type of the DTO object to marshal
     * @param dto
     *            the DTO object to be marshalled into XML
     * @return a formatted XML string representation of the given DTO object
     */
    public static <T> String marshalFormatted(T dto) {
        Map<String, Object> properties = new HashMap<>(DEFAULT_MARSHALLER_PROPERTIES);
        properties.put(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        return marshal(dto, null, properties, (Class<?>[]) null);
    }

    /**
     * Marshals the given DTO object into an XML string representation.
     *
     * @param <T>
     *            the type of the DTO object
     * @param dto
     *            the DTO object to be marshaled; if null, the method returns null
     * @param properties
     *            a map of properties to be set on the marshaller; can be null
     * @return the XML string representation of the DTO object, or null if the DTO is null
     * @throws Xml2jDtoException
     *             if an error occurs during marshalling or setting properties
     */
    public static <T> String marshal(T dto, Map<String, Object> properties) {
        return marshal(dto, null, properties, (Class<?>[]) null);
    }

    /**
     * Marshals the given DTO object into its XML representation using the specified XML schema.
     *
     * <p>
     * This method serializes the provided DTO object to an XML string, validating against the schema located at the given {@code schemaPath}. Default
     * marshaller properties are applied, and no additional classes are specified for context.
     * </p>
     *
     * @param <T>
     *            the type of the DTO object to marshal
     * @param dto
     *            the DTO object to be marshaled into XML
     * @param schemaPath
     *            the path to the XML schema file used for validation
     * @return the XML string representation of the DTO object
     */
    public static <T> String marshal(T dto, String schemaPath) {
        return marshal(dto, schemaPath, DEFAULT_MARSHALLER_PROPERTIES, (Class<?>[]) null);
    }

    /**
     * Marshals the given DTO object to its XML string representation, optionally validating against an XML schema.
     *
     * <p>
     * This method converts the provided DTO object to an XML string using JAXB. If a schema path is specified and valid, the XML output is validated
     * against the schema. Additional JAXB classes and marshaller properties can be supplied. Validation events are collected, and if any validation
     * errors occur, an {@link InvalidXmlSchemaException} is thrown. If marshalling fails due to malformed XML, a {@link MalformedXmlException} is
     * thrown.
     * </p>
     *
     * @param <T>
     *            the type of the DTO object to marshal
     * @param dto
     *            the DTO object to be marshalled; if {@code null}, returns {@code null}
     * @param schemaPath
     *            the path to the XML schema for validation; if blank, no validation is performed
     * @param marshallerProperties
     *            a map of properties to configure the JAXB marshaller
     * @param additionalClasses
     *            additional classes to be recognized by the JAXB context
     * @return the XML string representation of the DTO object, or {@code null} if the DTO is {@code null}
     * @throws InvalidXmlSchemaException
     *             if XML validation against the schema fails
     * @throws MalformedXmlException
     *             if marshalling fails due to malformed XML
     * @throws Xml2jDtoException
     *             if any other JAXB exception occurs during marshalling
     */
    public static <T> String marshal(T dto, String schemaPath, Map<String, Object> marshallerProperties, Class<?>... additionalClasses) {
        if (dto == null) {
            return null;
        }

        JAXBContext jaxbContext = createJAXBContext(dto, additionalClasses);

        List<ValidationEvent> events = new ArrayList<>();
        try {
            Marshaller marshaller = jaxbContext.createMarshaller();
            setMarshallerProperties(marshaller, marshallerProperties);

            XsdValidationEventCollector eventCollector = new XsdValidationEventCollector();
            marshaller.setEventHandler(eventCollector);

            // if schemaPath is empty -> no validation, only conversion
            if (StringUtils.isNotBlank(schemaPath)) {
                Schema schema = getSchema(schemaPath);
                if (schema != null) {
                    marshaller.setSchema(schema);
                }
            }
            StringWriter stringWriter = new StringWriter();
            marshaller.marshal(dto, stringWriter);
            events = eventCollector.getEvents();
            if (!events.isEmpty()) {
                throw new InvalidXmlSchemaException(events);
            }
            return stringWriter.getBuffer().toString();
        } catch (MarshalException e) {
            throw new MalformedXmlException(events, e);
        } catch (JAXBException e) {
            // we should not log the whole message, because it can be very long
            throw ExBuilder.newXml2jDtoException()
                    .withMessage("Failed DTO[{0}] -> String conversion: [{1}]", dto.getClass().getName(), e.getLocalizedMessage())
                    .withCause(e)
                    .build();
        }
    }

    private static <T> JAXBContext createJAXBContext(T dto, Class<?>... additionalClasses) {
        if (additionalClasses != null && additionalClasses.length > 0) {
            List<Class<?>> contextClasses = new ArrayList<>(Arrays.asList(additionalClasses));
            contextClasses.add(dto.getClass());
            return getJAXBContext(contextClasses.toArray(new Class<?>[0]));
        } else {
            return getJAXBContext(dto.getClass());
        }
    }

    private static void setMarshallerProperties(Marshaller marshaller, Map<String, Object> marshallerProperties) {
        if (marshallerProperties == null) {
            return;
        }
        for (Entry<String, Object> entry : marshallerProperties.entrySet()) {
            try {
                marshaller.setProperty(entry.getKey(), entry.getValue());
            } catch (PropertyException e) {
                throw ExBuilder.newXml2jDtoException()
                        .withMessage("Failed to set property name[{0}], value[{1}]: [{2}]", entry.getKey(), entry.getValue(), e.getLocalizedMessage())
                        .withCause(e)
                        .build();
            }
        }
    }

}
